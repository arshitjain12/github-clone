import { c } from 'react-compiler-runtime';
import React, { useRef, useState } from 'react';
import SegmentedControlButton from './SegmentedControlButton.js';
import { SegmentedControlIconButton } from './SegmentedControlIconButton.js';
import { ActionList } from '../ActionList/index.js';
import { useResponsiveValue } from '../hooks/useResponsiveValue.js';
import { isElement } from 'react-is';
import classes from './SegmentedControl.module.css.js';
import { clsx } from 'clsx';
import { isSlot } from '../utils/is-slot.js';
import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import { ActionMenu } from '../ActionMenu/ActionMenu.js';

const Root = t0 => {
  const $ = c(27);
  let ariaLabel;
  let ariaLabelledby;
  let children;
  let className;
  let fullWidth;
  let onChange;
  let rest;
  let size;
  let t1;
  if ($[0] !== t0) {
    ({
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledby,
      children,
      fullWidth,
      onChange,
      size,
      variant: t1,
      className,
      ...rest
    } = t0);
    $[0] = t0;
    $[1] = ariaLabel;
    $[2] = ariaLabelledby;
    $[3] = children;
    $[4] = className;
    $[5] = fullWidth;
    $[6] = onChange;
    $[7] = rest;
    $[8] = size;
    $[9] = t1;
  } else {
    ariaLabel = $[1];
    ariaLabelledby = $[2];
    children = $[3];
    className = $[4];
    fullWidth = $[5];
    onChange = $[6];
    rest = $[7];
    size = $[8];
    t1 = $[9];
  }
  const variant = t1 === undefined ? "default" : t1;
  const segmentedControlContainerRef = useRef(null);
  let t2;
  if ($[10] !== children || $[11] !== onChange) {
    t2 = onChange === undefined || React.Children.toArray(children).some(_temp);
    $[10] = children;
    $[11] = onChange;
    $[12] = t2;
  } else {
    t2 = $[12];
  }
  const isUncontrolled = t2;
  const responsiveVariant = useResponsiveValue(variant, "default");
  const isFullWidth = useResponsiveValue(fullWidth, false);
  let t3;
  if ($[13] !== children) {
    const selectedSegments = React.Children.toArray(children).map(_temp2);
    const hasSelectedButton = selectedSegments.some(_temp3);
    t3 = hasSelectedButton ? selectedSegments.indexOf(true) : 0;
    $[13] = children;
    $[14] = t3;
  } else {
    t3 = $[14];
  }
  const selectedIndexExternal = t3;
  const [selectedIndexInternalState, setSelectedIndexInternalState] = useState(selectedIndexExternal);
  const selectedIndex = isUncontrolled ? selectedIndexInternalState : selectedIndexExternal;
  let t4;
  if ($[15] !== ariaLabel || $[16] !== ariaLabelledby || $[17] !== children || $[18] !== className || $[19] !== isFullWidth || $[20] !== isUncontrolled || $[21] !== onChange || $[22] !== responsiveVariant || $[23] !== rest || $[24] !== selectedIndex || $[25] !== size) {
    const selectedChild = /*#__PURE__*/React.isValidElement(React.Children.toArray(children)[selectedIndex]) ? React.Children.toArray(children)[selectedIndex] : undefined;
    const getChildIcon = _temp4;
    const getChildText = _temp5;
    if (!ariaLabel && !ariaLabelledby) {
      console.warn("Use the `aria-label` or `aria-labelledby` prop to provide an accessible label for assistive technologies");
    }
    t4 = responsiveVariant === "dropdown" ? /*#__PURE__*/jsx(Fragment, {
      children: /*#__PURE__*/jsxs(ActionMenu, {
        children: [/*#__PURE__*/jsx(ActionMenu.Button, {
          "aria-label": ariaLabel && `${getChildText(selectedChild)}, ${ariaLabel}`,
          leadingVisual: getChildIcon(selectedChild),
          children: getChildText(selectedChild)
        }), /*#__PURE__*/jsx(ActionMenu.Overlay, {
          "aria-labelledby": ariaLabelledby,
          children: /*#__PURE__*/jsx(ActionList, {
            selectionVariant: "single",
            children: React.Children.map(children, (child_1, index) => {
              const ChildIcon = getChildIcon(child_1);
              if (! /*#__PURE__*/React.isValidElement(child_1)) {
                return null;
              }
              return /*#__PURE__*/jsxs(ActionList.Item, {
                selected: index === selectedIndex,
                onSelect: event => {
                  isUncontrolled && setSelectedIndexInternalState(index);
                  onChange && onChange(index);
                  child_1.props.onClick && child_1.props.onClick(event);
                },
                children: [ChildIcon, " ", getChildText(child_1)]
              }, `segmented-control-action-btn-${index}`);
            })
          })
        })]
      })
    }) : /*#__PURE__*/jsx("ul", {
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledby,
      ref: segmentedControlContainerRef,
      className: clsx(classes.SegmentedControl, className),
      "data-full-width": isFullWidth || undefined,
      "data-size": size,
      ...rest,
      children: React.Children.map(children, (child_2, index_0) => {
        if (! /*#__PURE__*/React.isValidElement(child_2)) {
          return null;
        }
        const sharedChildProps = {
          onClick: onChange ? event_0 => {
            onChange(index_0);
            isUncontrolled && setSelectedIndexInternalState(index_0);
            child_2.props.onClick && child_2.props.onClick(event_0);
          } : event_1 => {
            child_2.props.onClick && child_2.props.onClick(event_1);
            isUncontrolled && setSelectedIndexInternalState(index_0);
          },
          selected: index_0 === selectedIndex,
          style: {
            "--separator-color": index_0 === selectedIndex || index_0 === selectedIndex - 1 ? "transparent" : "var(--borderColor-default)",
            ...child_2.props.style
          }
        };
        if (responsiveVariant === "hideLabels" && /*#__PURE__*/React.isValidElement(child_2) && (child_2.type === SegmentedControlButton || isSlot(child_2, SegmentedControlButton))) {
          const {
            "aria-label": childAriaLabel,
            leadingVisual: leadingVisual_0,
            leadingIcon,
            children: childPropsChildren,
            ...restChildProps
          } = child_2.props;
          const visual = leadingVisual_0 !== null && leadingVisual_0 !== void 0 ? leadingVisual_0 : leadingIcon;
          if (!visual) {
            console.warn("A `leadingVisual` or `leadingIcon` prop is required when hiding visible labels");
          } else {
            return /*#__PURE__*/jsx(SegmentedControlIconButton, {
              "aria-label": childAriaLabel || childPropsChildren,
              icon: visual,
              className: classes.IconButton,
              ...sharedChildProps,
              ...restChildProps
            });
          }
        }
        return /*#__PURE__*/React.cloneElement(child_2, sharedChildProps);
      })
    });
    $[15] = ariaLabel;
    $[16] = ariaLabelledby;
    $[17] = children;
    $[18] = className;
    $[19] = isFullWidth;
    $[20] = isUncontrolled;
    $[21] = onChange;
    $[22] = responsiveVariant;
    $[23] = rest;
    $[24] = selectedIndex;
    $[25] = size;
    $[26] = t4;
  } else {
    t4 = $[26];
  }
  return t4;
};
Root.displayName = 'SegmentedControl';
const SegmentedControl = Object.assign(Root, {
  __SLOT__: Symbol('SegmentedControl'),
  Button: SegmentedControlButton,
  IconButton: SegmentedControlIconButton
});
function _temp(child) {
  return /*#__PURE__*/React.isValidElement(child) && child.props.defaultSelected !== undefined;
}
function _temp2(child_0) {
  return /*#__PURE__*/React.isValidElement(child_0) && (child_0.props.defaultSelected || child_0.props.selected);
}
function _temp3(isSelected) {
  return isSelected;
}
function _temp4(childArg) {
  if (/*#__PURE__*/React.isValidElement(childArg) && (childArg.type === SegmentedControlButton || isSlot(childArg, SegmentedControlButton))) {
    var _childArg$props$leadi;
    const leadingVisual = (_childArg$props$leadi = childArg.props.leadingVisual) !== null && _childArg$props$leadi !== void 0 ? _childArg$props$leadi : childArg.props.leadingIcon;
    if (leadingVisual) {
      if (isElement(leadingVisual)) {
        return leadingVisual;
      } else {
        const LeadingVisual = leadingVisual;
        return /*#__PURE__*/jsx(LeadingVisual, {});
      }
    }
  }
  if (/*#__PURE__*/React.isValidElement(childArg) && (childArg.type === SegmentedControlIconButton || isSlot(childArg, SegmentedControlIconButton))) {
    if (isElement(childArg.props.icon)) ; else {
      const Icon = childArg.props.icon;
      return /*#__PURE__*/jsx(Icon, {});
    }
  }
  return null;
}
function _temp5(childArg_0) {
  if (/*#__PURE__*/React.isValidElement(childArg_0) && (childArg_0.type === SegmentedControlButton || isSlot(childArg_0, SegmentedControlButton))) {
    return childArg_0.props.children;
  }
  return /*#__PURE__*/React.isValidElement(childArg_0) ? childArg_0.props["aria-label"] : null;
}

export { SegmentedControl };
