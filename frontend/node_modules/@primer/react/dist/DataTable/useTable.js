import { c } from 'react-compiler-runtime';
import { useState } from 'react';
import { strategies, SortDirection, DEFAULT_SORT_DIRECTION, transition } from './sorting.js';

function useTable(t0) {
  const $ = c(20);
  const {
    columns,
    data,
    initialSortColumn,
    initialSortDirection,
    getRowId
  } = t0;
  const [rowOrder, setRowOrder] = useState(data);
  const [prevData, setPrevData] = useState(data);
  const [prevColumns, setPrevColumns] = useState(columns);
  let t1;
  if ($[0] !== columns || $[1] !== initialSortColumn || $[2] !== initialSortDirection) {
    t1 = () => getInitialSortState(columns, initialSortColumn, initialSortDirection);
    $[0] = columns;
    $[1] = initialSortColumn;
    $[2] = initialSortDirection;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const [sortByColumn, setSortByColumn] = useState(t1);
  const {
    gridTemplateColumns
  } = useTableLayout(columns);
  if (columns !== prevColumns) {
    setPrevColumns(columns);
    if (sortByColumn) {
      const column_0 = columns.find(column => {
        var _column$id;
        const id = (_column$id = column.id) !== null && _column$id !== void 0 ? _column$id : column.field;
        return sortByColumn.id === id;
      });
      if (!column_0) {
        setSortByColumn(null);
      }
    }
  }
  let t2;
  let t3;
  let t4;
  if ($[4] !== columns || $[5] !== data || $[6] !== getRowId || $[7] !== prevData || $[8] !== rowOrder || $[9] !== sortByColumn) {
    let t5;
    if ($[13] !== sortByColumn) {
      t5 = column_1 => {
        var _column_1$id;
        const id_0 = (_column_1$id = column_1.id) !== null && _column_1$id !== void 0 ? _column_1$id : column_1.field;
        if (id_0 === undefined) {
          throw new Error("Expected either an `id` or `field` to be defined for a Column");
        }
        const sortable = column_1.sortBy !== undefined && column_1.sortBy !== false;
        return {
          id: id_0,
          column: column_1,
          isSortable() {
            return sortable;
          },
          getSortDirection() {
            if (sortByColumn && sortByColumn.id === id_0) {
              return sortByColumn.direction;
            }
            return SortDirection.NONE;
          }
        };
      };
      $[13] = sortByColumn;
      $[14] = t5;
    } else {
      t5 = $[14];
    }
    const headers = columns.map(t5);
    if (data !== prevData) {
      setPrevData(data);
      setRowOrder(data);
      if (sortByColumn) {
        sortRows(sortByColumn);
      }
    }
    const sortBy = function sortBy(header) {
      const sortState = {
        id: header.id,
        direction: sortByColumn && sortByColumn.id === header.id ? transition(sortByColumn.direction) : DEFAULT_SORT_DIRECTION
      };
      setSortByColumn(sortState);
      sortRows(sortState);
    };
    function sortRows(state) {
      const header_1 = headers.find(header_0 => header_0.id === state.id);
      if (!header_1) {
        throw new Error(`Unable to find header with id: ${state.id}`);
      }
      if (header_1.column.sortBy === false || header_1.column.sortBy === undefined) {
        throw new Error("The column for this header is not sortable");
      }
      const sortMethod = header_1.column.sortBy === true ? strategies.basic : typeof header_1.column.sortBy === "string" ? strategies[header_1.column.sortBy] : header_1.column.sortBy;
      setRowOrder(rowOrder_0 => rowOrder_0.slice().sort((a, b) => {
        if (header_1.column.field === undefined) {
          return 0;
        }
        if (typeof header_1.column.sortBy === "function") {
          if (state.direction === SortDirection.ASC) {
            return sortMethod(a, b);
          }
          return sortMethod(b, a);
        }
        const valueA = get(a, header_1.column.field);
        const valueB = get(b, header_1.column.field);
        if (valueA && valueB) {
          if (state.direction === SortDirection.ASC) {
            return sortMethod(valueA, valueB);
          }
          return sortMethod(valueB, valueA);
        }
        if (valueA) {
          return -1;
        }
        if (valueB) {
          return 1;
        }
        return 0;
      }));
    }
    t2 = headers;
    t3 = rowOrder.map(row => {
      const rowId = getRowId(row);
      return {
        id: `${rowId}`,
        getValue() {
          return row;
        },
        getCells() {
          return headers.map(header_2 => {
            var _header_2$column$rowH;
            return {
              id: `${rowId}:${header_2.id}`,
              column: header_2.column,
              rowHeader: (_header_2$column$rowH = header_2.column.rowHeader) !== null && _header_2$column$rowH !== void 0 ? _header_2$column$rowH : false,
              getValue() {
                if (header_2.column.field !== undefined) {
                  return get(row, header_2.column.field);
                }
                throw new Error(`Unable to get value for column header ${header_2.id}`);
              }
            };
          });
        }
      };
    });
    t4 = {
      sortBy
    };
    $[4] = columns;
    $[5] = data;
    $[6] = getRowId;
    $[7] = prevData;
    $[8] = rowOrder;
    $[9] = sortByColumn;
    $[10] = t2;
    $[11] = t3;
    $[12] = t4;
  } else {
    t2 = $[10];
    t3 = $[11];
    t4 = $[12];
  }
  let t5;
  if ($[15] !== gridTemplateColumns || $[16] !== t2 || $[17] !== t3 || $[18] !== t4) {
    t5 = {
      headers: t2,
      rows: t3,
      actions: t4,
      gridTemplateColumns
    };
    $[15] = gridTemplateColumns;
    $[16] = t2;
    $[17] = t3;
    $[18] = t4;
    $[19] = t5;
  } else {
    t5 = $[19];
  }
  return t5;
}
function getInitialSortState(columns, initialSortColumn, initialSortDirection) {
  if (initialSortColumn !== undefined) {
    const column = columns.find(column => {
      return column.id === initialSortColumn || column.field === initialSortColumn;
    });
    if (column === undefined) {
      if (process.env.NODE_ENV !== "production") {
        // eslint-disable-next-line no-console
        console.warn(`Warning: Unable to find a column with id or field set to: ${initialSortColumn}. Please provide a value to \`initialSortColumn\` which corresponds to a \`id\` or \`field\` value in a column.`);
      }
      return null;
    }
    if (column.sortBy === false || column.sortBy === undefined) {
      if (process.env.NODE_ENV !== "production") {
        // eslint-disable-next-line no-console
        console.warn(`Warning: The column specified by initialSortColumn={${initialSortColumn}} is not sortable. Please set \`sortBy\` to true or provide a sort strategy.`);
      }
      return null;
    }
    return {
      id: `${initialSortColumn}`,
      direction: initialSortDirection !== null && initialSortDirection !== void 0 ? initialSortDirection : DEFAULT_SORT_DIRECTION
    };
  }
  if (initialSortDirection !== undefined) {
    var _column$id2;
    const column = columns.find(column => {
      return column.sortBy !== false && column.sortBy !== undefined;
    });
    if (!column) {
      if (process.env.NODE_ENV !== "production") {
        // eslint-disable-next-line no-console
        console.warn(`Warning: An initialSortDirection value was provided but no columns are sortable. Please set \`sortBy\` to true or provide a sort strategy to a column.`);
      }
      return null;
    }
    const id = (_column$id2 = column.id) !== null && _column$id2 !== void 0 ? _column$id2 : column.field;
    if (id === undefined) {
      if (process.env.NODE_ENV !== "production") {
        // eslint-disable-next-line no-console
        console.warn(`Warning: Unable to find an \`id\` or \`field\` for the column: ${column}. Please set one of these properties on the column.`);
      }
      return null;
    }
    return {
      id,
      direction: initialSortDirection
    };
  }
  return null;
}
function useTableLayout(columns) {
  return {
    gridTemplateColumns: getGridTemplateFromColumns(columns).join(' ')
  };
}
function getGridTemplateFromColumns(columns) {
  return columns.map(column => {
    var _column$width;
    const columnWidth = (_column$width = column.width) !== null && _column$width !== void 0 ? _column$width : 'grow';
    let minWidth = 'auto';
    let maxWidth = '1fr';
    if (columnWidth === 'auto') {
      maxWidth = 'auto';
    }

    // Setting a min-width of 'max-content' ensures that the column will grow to fit the widest cell's content.
    // However, If the column has a max width, we can't set the min width to `max-content` because
    // the widest cell's content might overflow the container.
    if (columnWidth === 'grow' && !column.maxWidth) {
      minWidth = 'max-content';
    }

    // Column widths set to "growCollapse" don't need a min width unless one is explicitly provided.
    if (columnWidth === 'growCollapse') {
      minWidth = '0';
    }

    // If a consumer passes `minWidth` or `maxWidth`, we need to override whatever we set above.
    if (column.minWidth) {
      minWidth = typeof column.minWidth === 'number' ? `${column.minWidth}px` : column.minWidth;
    }
    if (column.maxWidth) {
      maxWidth = typeof column.maxWidth === 'number' ? `${column.maxWidth}px` : column.maxWidth;
    }

    // If a consumer is passing one of the shorthand widths or doesn't pass a width at all, we use the
    // min and max width calculated above to create a minmax() column template value.
    if (typeof columnWidth !== 'number' && ['grow', 'growCollapse', 'auto'].includes(columnWidth)) {
      return minWidth === maxWidth ? minWidth : `minmax(${minWidth}, ${maxWidth})`;
    }

    // If we reach this point, the consumer is passing an explicit width value.
    return typeof columnWidth === 'number' ? `${columnWidth}px` : columnWidth;
  });
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function get(object, path) {
  return path.split('.').reduce((value, key) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return value[key];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  }, object);
}

export { getGridTemplateFromColumns, useTable, useTableLayout };
